# За линией фронта
# Роберт успешно справился с вылазкой в тыл врага и раздобыл одну полоску из тетради в клетку длиной N клеток.
# Кроме того в руки Роберта попал лист изменений этой полоски. Враг выбирал две позиции i и j и записывал между ними новое сообщение
# (оба конца/позиции включены). При этом, если новое сообщение накладывалось на старое, то старое становилось навсегда утерянным.
# Напишите программу, которая определит, сколько на полоске осталось не утерянных сообщений.

# Формат входных данных: Первая строка содержит число N (1 ≤ N ≤ 10000) — длину клечатой полоски. Вторая строка содержит число K (1 ≤ K ≤ 1000) — 
# число сообщений. Следующие K строк содержат пары чисел i и j (1 ≤ i ≤ j ≤ N), задающих начало и конец сообщений.

# Формат результата: Выведите единственное число — количество не утерянных сообщений.

n = int(input())
k = int(input())
messenges = []
for it in range(k):
	i, j = input().split(' ')
	i = int(i)
	j = int(j)
	to_scratch = []
	for messenge in messenges:
		if i >= messenge[0] and i <= messenge[1]:
			to_scratch.append(messenge)
		elif j >= messenge[0] and j <= messenge[1]:
			to_scratch.append(messenge)
		elif i < messenge[0] and j > messenge[1]:
			to_scratch.append(messenge)
	for el in to_scratch:
		messenges.remove(el)
	messenges.append((i, j))

print(len(messenges))